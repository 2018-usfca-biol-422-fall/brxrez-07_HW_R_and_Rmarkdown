---
title: "Analysis of BLAST Results"
author: "Brian Rezende"
date: "October 8, 2018"
output: github_document
---

# Introduction

Have you ever thought about how many people enter into your institutes library a day? Quickly these spaces could turn into breeding grounds for bacteria and other microbial organisms. Though they remain invisible to the human eye, there is no denying their existence and ability to grow and spread exponentially.
Fortunately, advancements in the field of sequencing have allowed for analysis of environments we could never reach. In this analysis we'll examine diverse skin-associated bacterial communities and their comparison to human bacterial communities. Findings centered around these communities have found that skin bacterial communities are personalized, yet there is a link between the residual skin bacteria left on objects and bacteria on the object that the individual last touched. 
This **revolutionary forensic practice** predicts and can even match the bacteria on objects that have been left untouched for up to two weeks. The bacteria range in place of origin and allow us to better understand the mechanisms of bacteria, the degree of variability, and to one day become integrated with *traditional* forensic practices. 

# Methods
Fierer et. al provided the inital samples that promoted this analysis. They swabbed the palms of men and woman and computer mice at the University of Colorado, Boulder. By following a persistent trend that skin-associated bacteria leaves on objects and surfaces touched on a daily basis, they discovered abundant and diverse bacterial communities. The following criteria was required to properly link the bacteria from different environments:
*Recovered bacterial DNA allows for adequate characterization and comparison of communities.
*Persistance of skin-associated bacteria on surfaces for days to weeks
*Surfaces touched are effectively linked to individuals by assessing the similarity between the two bacterial communities. 
This was completed by carrying out three interrelated studies, which combined phylogenetic community analyses with high throughput pyrosequencing methods. 

## Sample origin and sequencing

Fierer and his collaborators first collected bacterial communities from individual keys from three keyboards. These keyboard communities were then compared to the communities found on the fingertips of the respective keyboard user. 
In order to further support their samples they obtained swabs from private and public computer keyboards to quantify the degree of correspondance between the owners "fingerprints" and their keyboard versus keyboards they have never used.
Using the skin bacteria communities they examined how similar they were with objects stored at **-20ÂºC**. This comparison is made due to the conditions closely matching ones that are imposed on stored samples before undergoing DNA extraction. The final step included using a Genbank database with over 250 hand surfaces and matching the objects to specific individuals by the bacteria that was collected. 
The pyrosequencing technique aforementioned was used, thus generating an average of 1,4000 bacterial 16S rRNA gene sequences per sample. 

Add about a paragraph here.

## Computational



And another paragraph or two here.

# Results

```{r load-libraries, message = FALSE}
# Be sure to install these packages before running this script
# They can be installed either with the install.packages() function
# or with the 'Packages' pane in RStudio

# load packages
library("dplyr")
library("tidyr")
library("knitr")
library("ggplot2")
```

```{r make-read-in-data-function}
# Output format from BLAST is as detailed on:
# https://www.ncbi.nlm.nih.gov/books/NBK279675/
# In this case, we used: '10 sscinames std'
# 10 means csv format
# sscinames means unique Subject Scientific Name(s), separated by a ';'
# std means the standard set of result columns, which are:
# 'qseqid sseqid pident length mismatch
# gapopen qstart qend sstart send evalue bitscore',


# this function takes as input a quoted path to a BLAST result file
# and produces as output a dataframe with proper column headers
# and the 'qseqid' column split into sample and seq number
read_blast_output <- function(filename) {
  data_in <- read.csv(filename,
                      header = FALSE, # files don't have column names in them
                      col.names = c("sscinames", # unique Subject Sci Name(s)
                                    "qseqid",    # Query Seq-id
                                    "sseqid",    # Subject Seq-id
                                    "pident",    # Percntge of identical matches
                                    "length",    # Alignment length
                                    "mismatch",  # Number of mismatches
                                    "gapopen",   # Number of gap openings
                                    "qstart",    # Start of alignment in query
                                    "qend",      # End of alignment in query
                                    "sstart",    # Start of alignment in subj
                                    "send",      # End of alignment in subject
                                    "evalue",    # Expect value
                                    "bitscore"))  # Bit score

  # Next we want to split the query sequence ID into
  # Sample and Number components so we can group by sample
  # They originally look like "ERR1942280.1"
  # and we want to split that into two columns: "ERR1942280" and "1"
  # we can use the separate() function from the tidyr library to do this
  # Note that we have to double escape the period for this to work
  # the syntax is
  # separate(column_to_separate,
  # c("New_column_name_1", "New_column_name_2"),
  # "seperator")
  data_in <- data_in %>%
    separate(qseqid, c("sample_name", "sample_number"), "\\.")
}
```

```{r read-in-BLAST-data}
# this makes a vector of all the BLAST output file names, including
# the name(s) of the directories they are in
files_to_read_in <- list.files(path = "output/blast",
                               full.names = TRUE)

# We need to create an empty matrix with the right number of columns
# so that we can rbind() each dataset on to it
joined_blast_data <- matrix(nrow = 0,
                            ncol = 14)

# now we loop over each of the files in the list and append them
# to the bottom of the 'joined_blast_data' object
# we do this with the rbind() function and the function we
# made earlier to read in the files, read_blast_output()
for (filename in files_to_read_in) {
  joined_blast_data <- rbind(joined_blast_data,
                             read_blast_output(filename))
}
```

```{r read-in-metadata-and-join}
# Next we want to read in the metadata file so we can add that in too
# This is not a csv file, so we have to use a slightly different syntax
# here the `sep = "\t"` tells the function that the data are tab-delimited
# and the `stringsAsFactors = FALSE` tells it not to assume that things are
# categorical variables
metadata_in <- read.table(paste0("data/metadata/",
                                 "fierer_forensic_hand_mouse_SraRunTable.txt"),
                          sep = "\t",
                          header = TRUE,
                          stringsAsFactors = FALSE)

# Finally we use the left_join() function from dplyr to merge or 'join' the
# combined data and metadata into one big table, so it's easier to work with
# in R the `by = c("Run_s" = "sample_name")` syntax tells R which columns
# to match up when joining the datasets together
joined_blast_data_metadata <- metadata_in %>%
  left_join(joined_blast_data,
            by = c("Run_s" = "sample_name"))
```

```{r show-levels}
levels(factor(joined_blast_data_metadata$env_feature_s))
```


```{r group-by-summarize}
#group by species name and calculate mean percent identity
joined_blast_data_metadata %>%
  group_by(sscinames, sample_type_s) %>%
  tally() %>%
  filter(n > 475) %>%
  ggplot(aes(x = sscinames,
             y = n,
             fill = sample_type_s)) +
  geom_col()+
  theme(axis.text.x = element_text(angle = 90,
                                   hjust = 1)) +
ggtitle("Most abundant species in sample types")
```

```{r similarity of mouse taxa on student hands}
# grouping and summarizing to see how the types of taxa are similar on male/female
# hands and computer mice
joined_blast_data_metadata %>%
  group_by(sample_type_s, sex_s, sscinames) %>%
  tally() %>%
  filter(n > 320) %>%
  ggplot(aes(x = sex_s,
             y = sample_type_s, 
             fill = sscinames)) +
  geom_bar(stat="identity") + 
ggtitle("Similarity of taxa in sample types")
```


```{r alignment length and errors}
#group and track the sequence alignment length and number of mismatches 
joined_blast_data_metadata %>%
  group_by(length, mismatch) %>%
  ggplot(aes(x = length,
             y = mismatch)) +
  geom_point() +
  labs(x = "Sequence length") +
  labs (y = "Number of Mismatches") +
ggtitle("Mismatches in sequence lengths")

```


```{r bitscore and organisms}
# Here using the 
joined_blast_data_metadata %>%
  filter(bitscore < 200,
         bitscore > 180) %>%
  group_by(sscinames) %>%
  summarize(mean_bitscore = mean(bitscore)) %>%
  ggplot(aes(x = sscinames,
             y = mean_bitscore))+
  geom_col() +
  theme(axis.text.x = element_text(angle = 90,
                                   hjust = 1)) +
  ggtitle("Bitscores")
```

```{r filtering score}
joined_blast_data_metadata %>%
  filter(bitscore < 200,
         bitscore > 150) %>%
  select(sscinames) %>%
  distinct() %>%
  pull() -> low_bitscore
```

```{r low bitscore vector }
joined_blast_data_metadata %>%
  filter(sscinames %in% low_bitscore) %>%
  group_by(sscinames) %>%
  tally() %>%
  arrange(desc(n))
```


```{r histograms}
# Here we're using the dplyr piping syntax to select a subset of rows matching a
# criteria we specify (using the filter) function, and then pull out a column
# from the data to make a histogram.
joined_blast_data_metadata %>%
  filter(env_material_s == "sebum") %>%
  ggplot(aes(x = pident)) +
    geom_histogram() +
    ggtitle("Percent Identity") +
    xlab("Percent")
```
```{r dplyr-example-1}
# using select () to extract particular columns of data
joined_blast_data_metadata %>%
  select(Organism_s, AvgSpotLen_l)

# use filter() to extract only certain rows that match a condition 
joined_blast_data_metadata %>%
  filter(env_material_s == "dust") 
```
Don't forget to report what your figures show in words, here in the Results section.

```{r summary-table}
# Finally, we'd like to be able to make a summary table of the counts of
# sequences for each subject for both sample types. To do that we can use the
# table() function. We add the kable() function as well (from the tidyr package)
# in order to format the table nicely when the document is knitted
kable(table(joined_blast_data_metadata$host_subject_id_s,
            joined_blast_data_metadata$sample_type_s))
```

# Discussion

Add 2-3 paragraphs here interpreting your results and considering future directions one might take in analyzing these data.

